const default_models = String.raw
`{"object_list":[{"name":"Object 1","model_name":"Cube","texture":{},"texture_name":"wood","position":{"x":50,"y":0,"z":0},"scale":{"x":0.05,"y":1.05,"z":0.05},"is_scale_linked":true,"rotation":{"x":0,"y":0,"z":0},"vertex_shader":"#version 300 es\nprecision highp float;\nin vec4 a_position;\nin vec2 a_texcoord;\nuniform mat4 u_cameraMatrix;\nuniform mat4 u_worldMatrix;\nuniform mat4 u_projectionMatrix;\nout vec3 v_position;\nout vec2 v_texcoord;\n \nvoid main() {\n  // Multiply the position by the matrix.\n  vec4 pos = u_worldMatrix * a_position;\n  v_position = pos.xyz;\n  gl_Position = u_projectionMatrix * u_cameraMatrix * pos;\n \n  // Pass the texcoord to the fragment shader.\n  v_texcoord = a_texcoord;\n}","fragment_shader":"#version 300 es\nprecision highp float;\n \n// Passed in from the vertex shader.\nin vec2 v_texcoord;\n \n// The texture.\nuniform sampler2D u_texture;\n \nout vec4 outColor;\n \nvoid main() {\n   outColor = texture(u_texture, v_texcoord);\n}","recompile":false},{"name":"Object-1","model_name":"Cube","texture":{},"texture_name":"wood","position":{"x":-50,"y":0,"z":0},"scale":{"x":0.05,"y":1.05,"z":0.05},"is_scale_linked":true,"rotation":{"x":0,"y":0,"z":0},"vertex_shader":"#version 300 es\nprecision highp float;\nin vec4 a_position;\nin vec2 a_texcoord;\nuniform mat4 u_cameraMatrix;\nuniform mat4 u_worldMatrix;\nuniform mat4 u_projectionMatrix;\nout vec3 v_position;\nout vec2 v_texcoord;\n \nvoid main() {\n  // Multiply the position by the matrix.\n  vec4 pos = u_worldMatrix * a_position;\n  v_position = pos.xyz;\n  gl_Position = u_projectionMatrix * u_cameraMatrix * pos;\n \n  // Pass the texcoord to the fragment shader.\n  v_texcoord = a_texcoord;\n}","fragment_shader":"#version 300 es\nprecision highp float;\n \n// Passed in from the vertex shader.\nin vec2 v_texcoord;\n \n// The texture.\nuniform sampler2D u_texture;\n \nout vec4 outColor;\n \nvoid main() {\n   outColor = texture(u_texture, v_texcoord);\n}","recompile":false},{"name":"Object-2","model_name":"Cube","texture":{},"texture_name":"dog","position":{"x":0,"y":0,"z":0},"scale":{"x":0.45,"y":0.95,"z":0.001},"is_scale_linked":true,"rotation":{"x":0,"y":0,"z":0},"vertex_shader":"#version 300 es\nprecision highp float;\nin vec4 a_position;\nin vec3 a_normal;\n\nuniform mat4 u_worldMatrix;\nuniform mat4 u_cameraMatrix;\nuniform mat4 u_projectionMatrix;\n\nout vec3 v_cameraPosition;\nout vec3 v_worldNormal;\n \nvoid main() {\n  // Multiply the position by the matrix.\n  vec4 pos = u_cameraMatrix * u_worldMatrix * a_position;\n  v_cameraPosition = pos.xyz;\n  v_worldNormal = mat3(u_worldMatrix) * a_normal;\n  gl_Position = u_projectionMatrix  * pos;\n}","fragment_shader":"#version 300 es\nprecision highp float;\n \n// Passed in from the vertex shader.\nin vec3 v_cameraPosition;\nin vec3 v_worldNormal;\n \n// The texture.\nuniform sampler2D u_texture;\nuniform samplerCube u_skybox;\nuniform vec3 u_worldCameraPosition;\n \nout vec4 outColor;\n \nvoid main() {\n  vec3 worldNormal = normalize(v_worldNormal);\n  vec3 eyeDir = normalize(v_cameraPosition);\n  vec3 direction = reflect(eyeDir, worldNormal);\n  outColor = texture(u_skybox, direction);\n}","recompile":false},{"name":"Object-3","model_name":"Cube","texture":{},"texture_name":"wood","position":{"x":0,"y":100,"z":0},"scale":{"x":0.5,"y":0.05,"z":0.05},"is_scale_linked":true,"rotation":{"x":0,"y":0,"z":0},"vertex_shader":"#version 300 es\nprecision highp float;\nin vec4 a_position;\nin vec2 a_texcoord;\nuniform mat4 u_cameraMatrix;\nuniform mat4 u_worldMatrix;\nuniform mat4 u_projectionMatrix;\nout vec3 v_position;\nout vec2 v_texcoord;\n \nvoid main() {\n  // Multiply the position by the matrix.\n  vec4 pos = u_worldMatrix * a_position;\n  v_position = pos.xyz;\n  gl_Position = u_projectionMatrix * u_cameraMatrix * pos;\n \n  // Pass the texcoord to the fragment shader.\n  v_texcoord = a_texcoord;\n}","fragment_shader":"#version 300 es\nprecision highp float;\n \n// Passed in from the vertex shader.\nin vec2 v_texcoord;\n \n// The texture.\nuniform sampler2D u_texture;\n \nout vec4 outColor;\n \nvoid main() {\n   outColor = texture(u_texture, v_texcoord);\n}","recompile":false},{"name":"Object-4","model_name":"Cube","texture":{},"texture_name":"wood","position":{"x":0,"y":-100,"z":0},"scale":{"x":0.5,"y":0.05,"z":0.05},"is_scale_linked":true,"rotation":{"x":0,"y":0,"z":0},"vertex_shader":"#version 300 es\nprecision highp float;\nin vec4 a_position;\nin vec2 a_texcoord;\nuniform mat4 u_cameraMatrix;\nuniform mat4 u_worldMatrix;\nuniform mat4 u_projectionMatrix;\nout vec3 v_position;\nout vec2 v_texcoord;\n \nvoid main() {\n  // Multiply the position by the matrix.\n  vec4 pos = u_worldMatrix * a_position;\n  v_position = pos.xyz;\n  gl_Position = u_projectionMatrix * u_cameraMatrix * pos;\n \n  // Pass the texcoord to the fragment shader.\n  v_texcoord = a_texcoord;\n}","fragment_shader":"#version 300 es\nprecision highp float;\n \n// Passed in from the vertex shader.\nin vec2 v_texcoord;\n \n// The texture.\nuniform sampler2D u_texture;\n \nout vec4 outColor;\n \nvoid main() {\n   outColor = texture(u_texture, v_texcoord);\n}","recompile":false},{"name":"Object-5","model_name":"Cube","texture":{},"texture_name":"dog","position":{"x":-500,"y":0,"z":0},"scale":{"x":1,"y":1,"z":1},"is_scale_linked":true,"rotation":{"x":-64.49,"y":-6.45,"z":-59.44},"vertex_shader":"#version 300 es\nprecision highp float;\nin vec4 a_position;\nin vec3 a_normal;\n\nuniform mat4 u_worldMatrix;\nuniform mat4 u_cameraMatrix;\nuniform mat4 u_projectionMatrix;\n\nout vec3 v_cameraPosition;\nout vec3 v_worldNormal;\n \nvoid main() {\n  // Multiply the position by the matrix.\n  vec4 pos = u_cameraMatrix * u_worldMatrix * a_position;\n  v_cameraPosition = pos.xyz;\n  v_worldNormal = mat3(u_worldMatrix) * a_normal;\n  gl_Position = u_projectionMatrix  * pos;\n}","fragment_shader":"#version 300 es\nprecision highp float;\n \n// Passed in from the vertex shader.\nin vec3 v_cameraPosition;\nin vec3 v_worldNormal;\n \n// The texture.\nuniform sampler2D u_texture;\nuniform samplerCube u_skybox;\nuniform vec3 u_worldCameraPosition;\n \nout vec4 outColor;\n \nvoid main() {\n  vec3 worldNormal = normalize(v_worldNormal);\n  vec3 eyeDir = normalize(v_cameraPosition);\n  vec3 direction = reflect(eyeDir, worldNormal);\n  outColor = texture(u_skybox, direction);\n}","recompile":false},{"name":"Object-6","model_name":"F-letter","texture":{},"texture_name":"grid","position":{"x":800,"y":0,"z":400},"scale":{"x":1,"y":1,"z":1},"is_scale_linked":true,"rotation":{"x":-4.65,"y":-66.31,"z":-180},"vertex_shader":"#version 300 es\nprecision highp float;\nin vec4 a_position;\nin vec2 a_texcoord;\nuniform mat4 u_cameraMatrix;\nuniform mat4 u_worldMatrix;\nuniform mat4 u_projectionMatrix;\nout vec3 v_position;\nout vec2 v_texcoord;\n \nvoid main() {\n  // Multiply the position by the matrix.\n  vec4 pos = u_worldMatrix * a_position;\n  v_position = pos.xyz;\n  gl_Position = u_projectionMatrix * u_cameraMatrix * pos;\n \n  // Pass the texcoord to the fragment shader.\n  v_texcoord = a_texcoord;\n}","fragment_shader":"#version 300 es\nprecision highp float;\n \n// Passed in from the vertex shader.\nin vec2 v_texcoord;\n \n// The texture.\nuniform sampler2D u_texture;\n \nout vec4 outColor;\n \nvoid main() {\n   outColor = texture(u_texture, v_texcoord / 8.0);\n}","recompile":false},{"name":"Object-7","model_name":"Cube","texture":{},"texture_name":"dog","position":{"x":-200,"y":0,"z":0},"scale":{"x":0.5,"y":0.5,"z":0.5},"is_scale_linked":true,"rotation":{"x":39.97,"y":-68.87,"z":0},"vertex_shader":"#version 300 es\nprecision highp float;\nin vec4 a_position;\nin vec3 a_normal;\n// uniform mat3 normalMatrix;\nuniform mat4 u_cameraMatrix;\nuniform mat4 u_worldMatrix;\nuniform mat4 u_projectionMatrix;\nout vec3 v_normal;\nout vec3 v_position;\nout vec4 v_viewPosition;\nout float speed;\nout float threadshold;\n\n\nfloat mrandom (vec2 st) {\n  // Random function borrowed here:\n  // https://thebookofshaders.com/10/\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvoid main()\n{\n  speed = 10.0;\n  v_normal = normalize(u_cameraMatrix * vec4(a_normal, 1.0)).xyz;\n  threadshold = a_position.y + mrandom(a_position.xy) * 0.4;\n\n  vec4 pos = u_worldMatrix * a_position;\n  v_position = pos.xyz;\n  v_viewPosition = u_projectionMatrix * u_cameraMatrix * pos;\n  gl_Position = u_projectionMatrix * u_cameraMatrix * pos;\n\n}\n","fragment_shader":" #version 300 es\n  precision highp float;\n  uniform float time;\n  uniform samplerCube u_skybox;\n  in vec3 v_position;\n  in vec4 v_viewPosition;\n  in vec3 v_normal;\n  in float threadshold;\n\n  out vec4 outColor;\n\n  struct LightSource {\n    vec3 light_color;\n    vec3 light_direction;\n    bool on;\n  };\n\n  struct PreBlendingLight {\n    vec4 AmbientLight;\n    vec4 DiffuseLight;\n    vec4 SpecularLight;\n    float sil;\n  };\n\n\n  const vec3 object_color = vec3(0.22, 0.412, 0.643);\n\n\n  //                              \\\n  // /-------------------------- \\\n  // |                          | \\\n  // |   Configurations BELOW   | \\\n  // |                          | \\\n  // --------------------------/ \\\n  //                              \\\n\n  // /----------  // | Dissolve |\n  // ----------/\n  // Turn-on or Turn-off the dissolve effect.\n  const bool dissolveOn = false;\n  const float dissolveSpeed = 10.0;\n  // The color of the dissove edge\n\n  // Try another color\n  // vec3 dissolve_start_color =vec3(1.,1.0, 0.);// Start with blue\n  // vec3 dissolve_end_color = vec3(0.733,0.165,0.145); // End with red\n\n\n  vec3 dissolve_start_color = vec3(0.98, 0.839, 0.7);   // Start with blue\n  vec3 dissolve_end_color = vec3(0.616, 0.435, 0.565);  // End with red\n\n  // /------------------  // | Translucent body |\n  // ------------------/\n  // Translucent material\n  // I cannot write blending, so this is the best I can do\n  const bool translucentBodyOn = true;\n  const float waxiness = 0.0;\n  const bool backgroundOn = true;\n\n  // /---------------------  // | Translucent Surface |\n  // ---------------------/\n  // Translucent material\n  const bool translucentSurfaceOn = true;\n  const float sharpness = 36.;\n\n  // /----------  // | Specular |\n  // ----------/\n  // Specular material\n  const bool specularOn = true;\n  const float specularFactor = 0.9;\n  const float shininess = 72.;\n\n  // /---------  // | Diffuse |\n  // ---------/\n  // Specular material\n  const bool diffuseOn = true;\n  const float diffuseFactor = 0.4;\n\n  // /---------  // | Ambient |\n  // ---------/\n  // Specular material\n  const float ambientFactor = 0.2 / 7.;\n\n\n\n  vec3 DiffuseColor(vec3 N, vec3 L, vec3 light_color) {\n    // https://en.wikibooks.org/wiki/GLSL_Programming/Unity/Diffuse_Reflection\n    // I_diffuse = I_incoming * K_diffuse * max(0, N . L)\n    float diffuse = diffuseFactor * max(0.0, dot(N, L));\n    return diffuse * (object_color * light_color);\n  }\n\n\n  vec3 AmbientColor(vec3 light_color) {\n    // https://en.wikibooks.org/wiki/Cg_Programming/Unity/Specular_Highlights\n    // This seems to be calculate by some global lighting algorithms (in Unity),\n    // but I haven't figure it out.\n\n    return ambientFactor * light_color * object_color;\n  }\n\n  vec3 SpecularColor(vec3 V, vec3 R, vec3 light_color) {\n    // I_s = I_i * K_s * max(0, R . V)^shiness\n    // https://en.wikibooks.org/wiki/Cg_Programming/Unity/Specular_Highlights\n    // The code provided on class seems not entirely the specular highlight.\n    // Maybe it also considered diffusion & ambient. I haven't figure it out.\n    vec3 specular_color = vec3(1.0, 1.0, 1.0);\n    return specularFactor * light_color * specular_color *\n        pow(max(0.0, dot(R, V)), shininess);\n  }\n\n  vec3 DiffuseTranslucency(vec3 L, vec3 N, vec3 light_color) {\n    // https://en.wikibooks.org/wiki/GLSL_Programming/Unity/Translucent_Surfaces\n    // I_dt = I_incoming * K_dt * max(0, L . -N)\n    //  vec3 diffuse_translucency_color = vec3(1,1,1);\n    vec3 diffuse_translucency_color = 0.25 * vec3(0.2, 0.4, 0.8);\n    return diffuse_translucency_color * light_color * max(0.0, dot(L, -N));\n  }\n\n  vec3 ForwardTranslucency(vec3 L, vec3 N, vec3 light_color) {\n    // https://en.wikibooks.org/wiki/GLSL_Programming/Unity/Translucent_Surfaces\n    // I_dt = I_incoming * K_dt * max(0, L . -N)^n_sharpness\n    vec3 forward_translucency_color = 0.25 * vec3(0.2, 0.4, 0.8);\n    //  vec3 forward_translucency_color = 0.25 * object_color;\n    return forward_translucency_color * light_color *\n        pow(max(0.0, dot(L, (-N))), sharpness);\n  }\n\n  float Silhouetteness(vec3 V, vec3 N) {\n    // https://en.wikibooks.org/wiki/Cg_Programming/Unity/Translucent_Bodies\n    // 1 - |Nè·¯L|\n\n    return min(1.0, 0.0 + 1.0 - abs(dot(V, N)));\n  }\n\n  vec3 Waxiness(vec3 L, vec3 N, vec3 light_color) {\n    // https://en.wikibooks.org/wiki/Cg_Programming/Unity/Translucent_Bodies\n    //  I_diffuse = I_incoming * K_diffuse *(w + (1-w)max(0, N . L)\n\n    //  vec3 forward_translucency_color = 0.25 * object_color;\n    return diffuseFactor * light_color * object_color *\n        (waxiness + (1. - waxiness) * max(0.0, dot(L, N)));\n  }\n\n  vec4 Background() {\n    vec3 distortedPosition = -(v_viewPosition.xyz + v_normal);\n    distortedPosition.y = -distortedPosition.y;\n    return texture(u_skybox, normalize(distortedPosition));\n  \n  }\n\n  vec4 LightColor(LightSource light) {\n    if (!light.on) return vec4(0.0, 0.0, 0.0, 0.);\n\n    // Initialization\n    vec3 L = normalize(light.light_direction);\n    vec3 N = normalize(v_normal);\n    vec3 V = normalize(-v_position);\n    vec3 R = normalize(reflect(-L, N));\n    vec3 color = light.light_color;\n    vec3 translucent_surface = vec3(0.0);\n    vec3 diffuse_color = vec3(0.0);\n    vec3 specular_color = vec3(0.0);\n    vec3 ambient_color = AmbientColor(color);\n    float sil = 1.0;\n    if (diffuseOn && !translucentBodyOn) {\n      diffuse_color = DiffuseColor(N, L, color);\n    }\n    if (translucentBodyOn) {\n      diffuse_color = Waxiness(N, L, color);\n    }\n    if (translucentSurfaceOn) {\n      translucent_surface +=\n          DiffuseTranslucency(L, N, color) + ForwardTranslucency(L, N, color);\n    }\n    if (specularOn) {\n      specular_color = SpecularColor(V, R, color);\n    }\n    //  if(translucentBodyOn && N.z < 0.) {\n    //    rescolor = vec3(0.0, 0.0,0.0);\n    //  }\n    if (translucentBodyOn) {\n      sil = Silhouetteness(normalize(-v_position), normalize(v_normal));\n    }\n    // On the back\n\n    return vec4(\n        ambient_color + translucent_surface + diffuse_color + specular_color,\n        sil);\n  }\n\n  vec4 AlphaBlend(vec4 a, vec4 b) {\n    // https://en.wikipedia.org/wiki/Alpha_compositing\n    // alpha_o = alpha_a + alpha_b(1-alpha_a);\n    // C_o = (C_a * alpha_a + C_b * alpha_b(1-alpha_a)/alpha_o\n\n    float alphaO = a.a + b.a * (1.0 - a.a);\n    vec3 CO = (a.xyz * a.a + b.xyz * b.a * (1.0 - a.a)) / alphaO;\n    return vec4(CO, alphaO);\n  }\n\n  void main() {\n    // Add a new Light source?\n    // First define \"LightSource <light_name> = LightSource(<light_color>,\n    // <light_direction>, true)\" Then append \"+ LightColor(<light_name>)\" to the\n    // color line (first line in main)\n\n    // A moving red light source\n    LightSource lightA = LightSource(\n        vec3(0.4, 0.4, 0.4),\n        vec3(0.3, sin(time * 20.0) * 2.0, cos(time * 20.0)) * 2.0, true);\n    // A moving green light source\n    LightSource lightE = LightSource(\n        vec3(0., 1., .0),\n        vec3(sin(time * 20.0) * 2.0, 0.3, cos(time * 20.0)) * 2.0, false);\n    // A moving blue light source\n    LightSource lightF = LightSource(\n        vec3(0., 0., .1),\n        vec3(cos(time * 20.0) * 2.0, sin(time * 20.0) * 2.0, 0.3), false);\n    // A stationary light source on the back.\n    LightSource lightB =\n        LightSource(vec3(0.0, 0.671, 0.8), vec3(0, 0., -1.0), true);\n    // A stationary light source on the front-left-bottom corner\n    LightSource lightC =\n        LightSource(vec3(0.8, 0.671, 0.0), vec3(-1.0, -1.0, 1.0), true);\n    // A stationary light source on the back-right-bottom corner\n    LightSource lightD =\n        LightSource(vec3(0.714, 0.0, 0.808), vec3(1.0, -1.0, 1.0), true);\n    // Stationary white light\n    LightSource lightG =\n        LightSource(vec3(1., 1.0, 1.0), vec3(0., 1., 0.), false);\n\n\n    // LightModel lightA = LightModel(vec3(1.,1.,1.0),  vec3(sin(time * 20.0)\n    // * 1.0,1.0,cos(time * 10.0))); LightModel lightB =\n    // LightModel(vec3(1.,0.,0.), vec3(0,1.,1.0));\n\n    vec4 color = LightColor(lightA) + LightColor(lightB) + LightColor(lightC) +\n        LightColor(lightD) + LightColor(lightF) + LightColor(lightG);\n    if (translucentBodyOn && backgroundOn) {\n      color = AlphaBlend(color, Background());\n    }\n\n\n    // LightColor(lightA) + LightColor(lightB) + LightColor(lightC) +\n    // LightColor(lightD) + LightColor(lightE) + LightColor(lightF)  /*new color\n    // add here*/;\n\n    if (dissolveOn) {\n      float t = threadshold - sin(time * dissolveSpeed) * 1.3 - 0.05;\n      if (t > 0.05)\n        discard;\n      else if (t > -0.05)\n        color = vec4(\n            mix(dissolve_start_color, dissolve_end_color, (t + 0.05) * 20.),\n            1.0);\n    }\n\n    outColor = color;\n  }\n","recompile":false}],"stack_top":8}`;
